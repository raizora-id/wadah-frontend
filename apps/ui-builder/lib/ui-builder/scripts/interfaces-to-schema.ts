import * as path from 'path';
import { generate } from 'ts-to-zod';
import { PropInterfaceData } from "./doc-to-interface";

/**
 * Generates a consolidated schemas file using string templating.
 * Ensures a single import of 'zod' and handles name clashes.
 * @param docs - Array of component documentation.
 * @returns The content of the consolidated schemas file as a string.
 */
export function interfacesToSchema(interfaceData: PropInterfaceData[]): string {
    // Initialize with a single import statement for zod
    let imports = `import { z } from 'zod';\n`;

    const componentImports: string[] = [];
    const schemaDefinitions: string[] = [];
    const componentDefinitions: string[] = [];

    // Object to keep track of import name counts for aliasing
    const importNameCount: { [key: string]: number } = {};

    const interfaceCount = interfaceData.length;

    interfaceData.forEach((interfaceDataItem) => {
        const { interfaceString, from, isDefault, filePath } = interfaceDataItem;
        let { componentName } = interfaceDataItem;

        let isDuplicate = false;
        const originalName = componentName;
        // Handle name collisions by aliasing
        if (importNameCount[componentName]) {
            importNameCount[componentName] += 1;
            componentName = `${componentName}${importNameCount[componentName]}`;
            isDuplicate = true;
        } else {
            importNameCount[componentName] = 1;
        }

        componentImports.push(getImportStatement({isDefault, originalName, componentName, filePath, isDuplicate}));

        // Generate Zod schema
        const zodGenerator = generate({ sourceText: interfaceString });
        let zodSchema: string;

        if (zodGenerator.errors && zodGenerator.errors.length > 0) {
            console.error(`Error generating Zod schema for ${componentName}:`, zodGenerator.errors);
            // Use an empty Zod object schema when errors occur
            zodSchema = 'z.object({})';
        } else {
            zodSchema = zodGenerator.getZodSchemasFile(`./TempSchemas.ts`);
            // Remove the import { z } from 'zod'; from each generated schema
            zodSchema = zodSchema.replace(/^import\s+\{\s*z\s+\}\s+from\s+['"]zod['"];\s*/gm, '');
            // Remove the // Generated by ts-to-zod
            zodSchema = zodSchema.replace(/\/\/ Generated by ts-to-zod\n/, '');
            // Remove the variable declaration of the schema like const reactFunctionComplexTypesPropsSchema =
            zodSchema = zodSchema.replace(/^export const \w+PropsSchema = /, '');

            if (!zodSchema.trim()) {
                console.error(`Zod schema for ${componentName} is empty after replacements.`);
                // Fallback to empty Zod object if schema is empty
                zodSchema = 'z.object({})';
            } else {
                // Handle name clashes by appending component name
                zodSchema = `${ zodSchema.trim() }`;
            }
        }

        // Define the schema name using the aliased component name
        const schemaName = `${ componentName }Schema`;

        schemaDefinitions.push(`
export const ${ schemaName } = ${ zodSchema }
          `);

        // Prepare component definition entry using the aliased component name
        componentDefinitions.push(`
    ${ componentName }: {
      component: ${ componentName },
      from: '${ from }',
      schema: ${ schemaName }
    },`);
    });

    imports += componentImports.join('\n') + '\n\n';
    const schemas = schemaDefinitions.join('\n');
    const definitions = `
export const ComponentDefinitions = {
${ componentDefinitions.join('\n') }
};
`;

    const finalSchema = patchPartials(`${ imports }\n${ schemas }\n${ definitions }`);
    console.log(`Merged ${ interfaceCount } interfaces into schema.`);
    return finalSchema;
}

/**
 * Generates the appropriate import statement based on whether the component is a default export.
 * @param doc - The component documentation.
 * @returns The appropriate import statement.
 */
function getImportStatement({isDefault, originalName, componentName, filePath, isDuplicate}:{isDefault: boolean, originalName: string, componentName: string, filePath: string, isDuplicate: boolean}): string {
    const filenameWithoutExt = path.basename(filePath, '.tsx');

    return isDefault
        ? `import ${componentName} from './${filenameWithoutExt}';`
        : `import { ${originalName} ${isDuplicate ? `as ${componentName} ` : ''}} from './${filenameWithoutExt}';`;
}

function patchPartials(schema: string) {
    // patch partials because ts-to-zod puts them in the wrong place
    return schema.replace(/\.partial\(\)/g, "");
}